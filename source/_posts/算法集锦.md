---
title: 算法集锦
tags:
  - js
categories:
  - 算法
date: 2024-03-07 10:57:35
---

# 动态规划

## 解题思路

1. 思路

**确定状态转移方程**
**不同规模相同问题之间的关系**
**注意是否有后效性**

2. 实现
 
代码层面，一般用递归

## 经典题目

### 斐波那契数列

```javascript
function dp(n) {
  if (n === 1 || n === 2) {
    return 1;
  }
  return dp(n - 1) + dp(n -2);
}
```

### 背包问题

题目：有一个背包，容量为C，现在有n种不同的物品，编号为0...n-1，其中每一件物品的重量为weight(i)，价值为value(i)，问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大

背包重量：6
|      | 0 | 1 | 2 | 3 | 4 |
| value | 5 | 10 | 3 | 6 | 3 |
| weight | 2 | 5 | 1 | 4 | 3 | 

思路：

| 物品编号/重量 | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| 0 |  |  |  |  |  |
| 1 |  |  |  |  |  | 
| 2 |  |  |  |  |  | 
| 3 |  |  |  |  |  | 
| 4 |  |  |  |  |  | 

i 表示物品编号，j表示背包重量
求dp[i][j]的最大值，那么i这件物品可以选也可以不选，
如果不选，那么dp[i][j] = dp[i-1][j]，
如果选，那么dp[i][j] = dp[i-1][j-weight(i)] + value(i)
取两者最大值


解题：
```javascript
function knapsack(capacity, weight, value, n) {
  if (n === 0 || capacity === 0) {
    return 0;
  }
  const dp = [];
  for (let i = 0; i < n; i++) {
    dp[i] = [];
    for (let j = 0; j <= capacity; j++) {
      if (i === 0) {
        dp[i][j] = j < weight[i] ? 0 : value[i];  
      } else if (j < weight[i]) {
        dp[i][j] = dp[i-1][j];
      } else {
        dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight(i)] + value(i))
      }
    }
  }
  return dp[n-1][capacity];
}
// 空间复杂度 O(n*capacity)
```

优化：

```javascript
function knapsack(capacity, weight, value, n) {
  if (n === 0 || capacity === 0) {
    return 0;
  }
  let result = [];
  // 第一行最优解
  for (let i = 0; i <= capacity; i++) {
    result[i] = i < weight[0] ? 0 : value[0];
  }
  for (let i = 1; i <= n; i++) {
    const next = [];
    for (let j = 0; j <= capacity; j++) {
      if (j < weight[i]) {
        next[j] = result[j];
      }else {
        next[j] = Math.max(result[j], result[j-weight[i]] + value[i]);
      }
    }
    result = next;
  }
  return result[capacity];
}
// 空间复杂度 O(capacity)
```


### 青蛙上台阶

题目：每次可以跳1级或者2级，问跳到第n级有多少种跳法

思路：跳到第n级，可以从第n-1级跳1级，也可以从第n-2级跳2级，所以跳到第n级的跳法就是跳到第n-1级的跳法加上跳到第n-2级的跳法

解题：
```javascript
function jump(n) {
  if (n === 1 || n === 2) {
    return n;
  }
  return jump(n - 1) + jump(n - 2);
}
```

优化
```javascript
var climbStairs = function(n) {
    let p = 0,q = 0, r =1;
    for (let i = 1; i <= n; i++) {
        p = q;
        q = r;
        r = p + q;
    }
    return r
};
```

### 骑士救公主

### 恢复空格

题目：在英文中，我们可以使用空格来分割句子，使得句子更加美观。现在给定一个没有空格的句子，以及一个包含非空单词列表的字典，你需要判断这个句子是否可以被空格拆分为一个或多个在字典中出现的单词

### 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    const len = nums.length;
    const dp = new Array(len).fill(1);
    for (let i = 0; i < len; i++) {
        for(let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }
    return Math.max(...dp);
};
```
# 数组/字符串

### 88. 合并两个有序数组

- 题目描述

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

非递减顺序：升序排序，可能有相同数字

- 示例

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]

输入：nums1 = [1,2,5,0,0,0,0,0], m = 3, nums2 = [2,3,6,7,8], n = 5

- 解题思路

1. 直接合并后排序

时间复杂度：O((m+n)log(m+n))
空间复杂度：O(log(m+n))

```javascript
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m, n, ...nums2); // 合并
    nums1.sort((a, b) => a - b); // 排序
}
```

2. 双指针

时间复杂度：O(m+n)
空间复杂度：O(m+n)

依次比较两个数组的元素，将较小的放入新数组中，最后将新数组的元素复制到nums1中

```javascript
var merge = function(nums1, m, nums2, n) {
    let p1 = 0, p2 = 0;
    const sorted = new Array(m + n).fill(0);
    var cur;
    while (p1 < m || p2 < n) {
        if (p1 === m) {
            cur = nums2[p2++];
        } else if (p2 === n) {
            cur = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            cur = nums1[p1++];
        } else {
            cur = nums2[p2++];
        }
        sorted[p1 + p2 - 1] = cur;
    }
    for (let i = 0; i != m + n; ++i) {
        nums1[i] = sorted[i];
    }
};
```

3. 逆向双指针(推荐！)

时间复杂度：O(m+n)
空间复杂度：O(1)

因为nums1后面有空间，所以可以从后往前比较，将较大的放入nums1的后面

```javascript
var merge = function(nums1, m, nums2, n) {
  let i = m - 1; // nums1 指针
  let j = n - 1; // nums2 指针
  let tail = m + n - 1; // nums1 尾指针
  let cur;
  while(i > -1 || j > -1) {
    if (i === -1) {
      cur = nums2[j--];
    } else if (j === -1) {
      cur = nums1[i--];
    } else if (nums1[i] < nums2[j]) {
      cur = nums2[j--]; 
    } else {
      cur = nums1[i--];
    }
    nums1[tail--] = cur;
  }
}
```

### 27. 移除元素

- 题目描述

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

- 示例

输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

- 解题思路

1. 直接删除
```javascript
var removeElement = function(nums, val) {
    const len = nums.length
    for (let i = len - 1; i >= 0; i--) {
        if (nums[i] === val) {
            nums.splice(i, 1);
        }
    }
    return nums.length;
};
```
2. 双指针

时间复杂度：O(n)
空间复杂度：O(1)

left和right都指向第一个元素，right为将要处理的元素，left为要赋值的位置，right向后遍历，当遍历到的元素不为val时，将值赋给left

```javascript
var removeElement = function(nums, val) {
  let left = 0;
  for (let right = 0, len = nums.length; right < len; right++) {
    if (nums[right] !== val) {
      nums[left] = nums[right];
      left++;
    }
  }
  return left;
}
```

3. 双指针优化

left 和 right指针分别放在数组收尾，判断left的值，如果为val，将right的值赋值过来
相较方案2避免了需要保留的元素的重复赋值操作

```javascript
var removeElement = function(nums, val) {
  let left = 0;
  let right = nums.length;
  while (left < right) {
    if (nums[left] === val) {
      nums[left] = nums[right - 1];
      right--;
    } else {
      left++;
    }
  }
  return left;
}
```

### 26. 删除有序数组中的重复项

- 题目描述

给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。nums 的其余元素与 nums 的大小不重要。

- 示例

输入：nums = [1,1,2]
输出：2, nums = [1,2,]

- 解题思路

1. 双指针

时间复杂度：O(n)
空间复杂度：O(1)

```javascript
// for可改为while
var removeDuplicates = function(nums) {
    if (nums === null || nums.length === 0) { return 0}
    let left = 1;
    for (let right = 1, len = nums.length; right < len; right++) {
        const item = nums[right]
        if (item !== nums[right - 1]) {
            nums[left] = item
            left++;
        }
    }
    return left;
};
```

### 80. 删除有序数组中的重复项 II

- 题目描述

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

- 示例

输入：nums = [1,1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]

- 解题思路

1. 双指针

时间复杂度：O(n)
空间复杂度：O(1)

比较当前元素和上上个元素是否相等

```javascript
var removeDuplicates = function(nums) {
  const len = nums.length;
  if (len <= 2) {
    return len;
  }
  let fast = 2, slow = 2;
  while (fast < len) {
    if (nums[slow - 2] !== nums[fast]) {
      nums[slow] = nums[fast];
      slow++;
    }
    fast++;
  }
  return slow;
}
```