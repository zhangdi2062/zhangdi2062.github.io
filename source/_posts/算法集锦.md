---
title: 算法集锦
tags:
  - js
categories:
  - 算法
date: 2024-03-07 10:57:35
---

# 动态规划

## 解题思路

1. 思路

**确定状态转移方程**
**不同规模相同问题之间的关系**
**注意是否有后效性**

2. 实现
 
代码层面，一般用递归

## 经典题目

### 斐波那契数列

```javascript
function dp(n) {
  if (n === 1 || n === 2) {
    return 1;
  }
  return dp(n - 1) + dp(n -2);
}
```

### 背包问题

题目：有一个背包，容量为C，现在有n种不同的物品，编号为0...n-1，其中每一件物品的重量为weight(i)，价值为value(i)，问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大

背包重量：6
|      | 0 | 1 | 2 | 3 | 4 |
| value | 5 | 10 | 3 | 6 | 3 |
| weight | 2 | 5 | 1 | 4 | 3 | 

思路：

| 物品编号/重量 | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| 0 |  |  |  |  |  |
| 1 |  |  |  |  |  | 
| 2 |  |  |  |  |  | 
| 3 |  |  |  |  |  | 
| 4 |  |  |  |  |  | 

i 表示物品编号，j表示背包重量
求dp[i][j]的最大值，那么i这件物品可以选也可以不选，
如果不选，那么dp[i][j] = dp[i-1][j]，
如果选，那么dp[i][j] = dp[i-1][j-weight(i)] + value(i)
取两者最大值


解题：
```javascript
function knapsack(capacity, weight, value, n) {
  if (n === 0 || capacity === 0) {
    return 0;
  }
  const dp = [];
  for (let i = 0; i < n; i++) {
    dp[i] = [];
    for (let j = 0; j <= capacity; j++) {
      if (i === 0) {
        dp[i][j] = j < weight[i] ? 0 : value[i];  
      } else if (j < weight[i]) {
        dp[i][j] = dp[i-1][j];
      } else {
        dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight(i)] + value(i))
      }
    }
  }
  return dp[n-1][capacity];
}
// 空间复杂度 O(n*capacity)
```

优化：

```javascript
function knapsack(capacity, weight, value, n) {
  if (n === 0 || capacity === 0) {
    return 0;
  }
  let result = [];
  // 第一行最优解
  for (let i = 0; i <= capacity; i++) {
    result[i] = i < weight[0] ? 0 : value[0];
  }
  for (let i = 1; i <= n; i++) {
    const next = [];
    for (let j = 0; j <= capacity; j++) {
      if (j < weight[i]) {
        next[j] = result[j];
      }else {
        next[j] = Math.max(result[j], result[j-weight[i]] + value[i]);
      }
    }
    result = next;
  }
  return result[capacity];
}
// 空间复杂度 O(capacity)
```


### 青蛙上台阶

题目：每次可以跳1级或者2级，问跳到第n级有多少种跳法

思路：跳到第n级，可以从第n-1级跳1级，也可以从第n-2级跳2级，所以跳到第n级的跳法就是跳到第n-1级的跳法加上跳到第n-2级的跳法

解题：
```javascript
function jump(n) {
  if (n === 1 || n === 2) {
    return n;
  }
  return jump(n - 1) + jump(n - 2);
}
```

优化
```javascript
var climbStairs = function(n) {
    let p = 0,q = 0, r =1;
    for (let i = 1; i <= n; i++) {
        p = q;
        q = r;
        r = p + q;
    }
    return r
};
```

### 骑士救公主

### 恢复空格

题目：在英文中，我们可以使用空格来分割句子，使得句子更加美观。现在给定一个没有空格的句子，以及一个包含非空单词列表的字典，你需要判断这个句子是否可以被空格拆分为一个或多个在字典中出现的单词

### 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    const len = nums.length;
    const dp = new Array(len).fill(1);
    for (let i = 0; i < len; i++) {
        for(let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }
    return Math.max(...dp);
};
```