---
title: 每日学习
date: 2024-02-23 13:14:09
tags:
- js
- css
categories:
- 前端
---

### 2024/2/23

#### 函数重载

应用场景：同一个函数支持多种参数的调用，并返回对应的结果

```js
function getUsers(...args){}
getUsers(); // 得到全部数据
getUsers(1); // 获取第一页数据
getUsers(1,20); // 获取第一页前20条数据
getUsers('男'); // 获取性别为男的数据
```

具体实现：

```js
// 封装
function createOverload() {
    const map = new Map();
    function overload(...keys) {
        const types = keys.map(it => typeof it).join(',')
        const fn = map.get(types);
        if (!fn) {
            throw new TypeError('未找到对应实现')
        }
        return fn.apply(this, keys);
    }
    overload.addImpl = function(...args) {
        const fn = args.pop();
        if (typeof fn !== 'function') {
            throw new TypeError('最后一个参数必须是处理函数');
        }
        // 将参数拼接形成key
        map.set(args.join(','), fn);
    }
    return overload;
}

// 实现
const getUsers = createOverload();
getUsers.addImpl(() => {
    console.log('返回所有数据')
})
getUsers.addImpl('number', (n) => {
    console.log('返回第一页数据', n)
})
getUsers.addImpl('number', 'number', (n1, n2) => {
    console.log('返回第一页前20条数据', n1, n2)
})
getUsers.addImpl('string', (str) => {
    console.log('返回xx数据', str)
})

// 使用
getUsers(); // 得到全部数据
getUsers(1); // 获取第一页数据
getUsers(1,20); // 获取第一页前20条数据
getUsers('男'); // 获取性别为男的数据

```

#### 基于css变量的主题切换

应用场景：亮色、暗色主题切换，以适应用户喜好

实现思路：

```js
// 第一步：给html根节点设置data-theme属性，值为主题值
// 第二步：css中设置两种或多种主题下的css变量，如字体颜色、背景颜色等，不同选择器应用css变量
// 第三步：在切换主题时修改data-theme属性值，并将主题值存储到localstorage中
```

#### 封装resize指令

应用场景：监控元素尺寸的变化，拖拽重新渲染图表，

具体实现：封装vue自定义指令

```js
// WeakMap不影响垃圾回收
const map = new WeakMap();
// 尺寸观察者
const ob = new ResizeObserver(entries => {
    for (const entry of entries) {
        const { target } = entry;
        // 获取dom的回调函数
        const handler = map.get(target);
        if (handler) {
            // 以下代码可按需求扩展
            const box = entry.borderBoxSize[0];
            handler({width: box.inlineSize, height: box.blockSize});
        }
    }
})

export default {
    mounted(el, binding) {
        // 监视尺寸变化
        ob.observe(el);
        map.set(el, binding.value);
    },
    unmounted() {
        // 取消监听
        ob.unobserve(dom);
    }
    
}

// 使用
<div v-size-ob="change"></div>
function change(w,h) {
    updateChart(w, h)
}
```

#### 触发迅雷下载

应用场景：调用迅雷的下载

具体实现：

```js
// 前提，a标签的href值为普通下载链接地址
// 给a元素加个data-thunder属性，以便筛选需要训练下载的标签
const links = document.querySelectorAll('a[data-thunder]');
for(const link of links) {
    const href = `AA${link.href}ZZ`;
    const base64 = btoa(href);
    link.href = `thunder://${base64}`;
}

```

#### flap列表切换顺序动画

#### for in和for of

for in

1. 遍历对象的可枚举属性，包括对象自身的属性以及继承的属性
2. 不保证遍历顺序

for of 

1. 遍历可迭代对应的属性值
2. 迭代顺序与索引顺序一致
3. 对象不能迭代

引申知识：

判断是否是可迭代对象：`data != null && typeof data[Symbol.iterator] === 'function'`

#### requestAnimationFrame

出现原因：解决定时器刷新频率不稳定问题

应用场景：动画

具体实现：

```js
// requestAnimationFrame和setTimeout类似，调用是一次性的
// 接收一个函数，该回调函数会在浏览器下一次重绘之前执行。回调函数执行次数通常与浏览器屏幕刷新次数相匹配
// 当页签在后台运行时，requestAnimationFrame会被停止调用，用来提升性能和电池寿命

let timer = null;
let i = 0;
function fn() {
    if (i < 100) {
        i++;
        timer = requestAnimationFrame(fn);
    } else {
        cancelAnimationFrame(timer);
    }
}
fn();
```

#### 消除异步的传染性

应用场景：当函数A为异步请求时，函数B使用了函数A则函数B也需异步，函数C使用函数B也需要异步，导致所有依赖函数都要加上async await

解决思路：消除始作俑函数的异步，参考react中做法，在异步函数中抛出错误，等待异步完成后，将结果缓存下来，重新执行一开始的函数

具体实现：

```js
// 原代码
async function getUser() {
    return await fetch('https://api.github.com/users/1')
}

async function m() {
    return await getUser();
}

async function main() {
    const user = await m();
    console.log(user);
}
main()
```

```js
// 实现代码
 function getUser() {
    return fetch('https://api.github.com/users/1')
}

 function m() {
    return getUser();
}

 function main() {
    console.log('打印');
    const user = m();
    console.log(user);
}

function run(func) {
    // 1. 改动fetch
    // 2. 执行func
    // 3. 还原fetch
    const _fetch = window.fetch;
    let catchData = {
        status: 'pending',
        value: null
    };
    function newFetch(...args) {
        if (catchData.status === 'fulfilled') {
            return catchData.value;
        }
        if (catchData.status === 'rejected') {
            throw catchData.value;
        }
        const promise = _fetch(...args).then(res => res.json()).then(data => {
            catchData = { 
                status: 'fulfilled',
                value: data
            };
        }).catch(err => {
            catchData = { 
                status: 'rejected',
                value: err
            };
        })
        throw promise;
    }
    window.fetch = newFetch;
    try {
        func();
    } catch (e) {
        if (e instanceof Promise) {
            e.finally(() => {
                window.fetch = newFetch;
                func();
                window.fetch = _fetch;
            })
        }
    }
    window.fetch = _fetch;
}

run(main);
```


#### Vue3效率提升

1. 静态提升
2. 模板转字符串
3. 缓存事件函数
4. Block Tree
5. PatchFlag

### 2024/2/24

#### 跟随系统的主题切换

> 注：windows10的主题色切换在个性化-颜色-默认应用样式

```css
@media (prefers-color-scheme: dark) {
    :root {
        --background: #fff;
    }
}

@media (prefers-color-scheme: light) {
  
    html[data-theme=dark] {
        --background: #000;
    }
}

body {
    background: var(--background)
}
```

```js
// 获取系统主题
const match = matchMedia('(prefers-color-scheme: light)');
console.log(match.matches) // true or false
// 监听变化
match.addEventListener('change', followOS);
```

#### ts 协变和逆变

可以不记含义，只需保证 **__类型安全：所有成员可用__**

#### 文字穿透效果

```css
span {
    /* 文字效果 */
    color: transparent;
    -webkit-text-stroke: 2px #fff;
    /* 背景处理 */
    background: var(--bg);
    background-clip: text;
}
```

#### 给fetch添加超时功能

```js
function createRequestWithTimeout(time = 5000) {
    return function (url, options) {
        return new Promise((resolve, reject) => {
            // 因为promise的状态只会改变一次，所以fetch和setTimeout并列即可
            // 超时后取消请求
            const controller = new AbortController();
            options = options || {};
            if (options.signal) {
                const { signal } = options;
                signal.addEventListener('abort', () => {
                    controller.abort();
                })
            } else {
                options.signal = controller.signal;
            }
            fetch(url, options).then(resolve, reject);
            setTimeout(() => {
                reject(new Error('请求超时'));
                controller.abort();
            }, time);
        })
    }
}

// 使用
const request= createRequestWithTimeout(3000);
requset('url', {})
```

#### 用css自定义咖啡



#### 无限视差滚动

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;

        }
        img {
            width: 100%;
            height: 100%;
        }
        .item {
            width: 100vw;
            height: 100vh;
            transition: height .3s;
        }
        .prev, .next {
            height: 0;
        }
        .scroll-down .next {
            height: 100vh;
        }
        .scroll-up .prev {
            height: 100vh;
        }
        .scroll-down .cur, .scroll-up .cur {
            height: 0;
        }
        
    </style>
</head>
<body>
    <div id="container">
    </div>
    <script>
        const container = document.getElementById('container');
        // 图片索引
        let curIndex = 0;
        const imgArr = [
            './img/1.jpg',
            './img/2.jpg',
            './img/3.jpg',
            './img/4.jpg',
            './img/5.jpg',
        ]

        function getPrevIndex() {
            return curIndex === 0 ? imgArr.length - 1 : curIndex - 1;
        }

        function getNextIndex() {
            return curIndex === imgArr.length - 1 ? 0 : curIndex + 1;
        }

        function createElement(i) {
            const div = document.createElement('div')
            div.className = 'item'; 
            const img = document.createElement('img');
            img.src = imgArr[i];
            div.appendChild(img);
            container.appendChild(div);
            return div;
        }

        function resetElements() {
            container.innerHTML = '';
            const prevIndex = getPrevIndex();
            const nextIndex = getNextIndex();
            createElement(prevIndex).classList.add('prev');
            createElement(curIndex).classList.add('cur');
            createElement(nextIndex).classList.add('next');

        }
        resetElements();
        let isAnimation = false
        // 监听滚轮事件
        document.addEventListener('wheel', (e) => {
            if (isAnimation) {
                return;
            }
            const {deltaY} = e;
            if (deltaY === 0) {
                return;
            }
            isAnimation = true;
            if (deltaY > 0) {
                curIndex = getNextIndex();
                container.classList.add('scroll-down');
            } else {
                curIndex = getPrevIndex();
                container.classList.add('scroll-up');

            }
        })

        container.addEventListener('transitionend', () => {
            isAnimation = false;
            container.classList.remove('scroll-down');
            container.classList.remove('scroll-up');
            resetElements();
        })
    </script>
</body>
</html>
```


### 2024/2/25

#### Promise构造器的实现

```js
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

class MyPromise {
    constructor(executor) {
        const resolve = (result) => {
            this.#changeStatus(FULFILLED, result);
        };
        const reject = (result) => {
            this.#changeStatus(REJECTED, result);
        };
        try {
            executor(resolve, reject);
        } catch (error) {
            reject(error);
        }
    }
    #status = PENDING;
    #result = undefined;

    #changeStatus(status, result) {
        // 状态一旦改变，就不能再次改变
        if (this.#status !== PENDING) {
            return;
        }
        this.#status = status;
        this.#result = result;
    }
}

const myPromise = new MyPromise((resolve, reject) => {
    console.log('MyPromise');
    resolve(111);
});

console.log(myPromise);
```