---
title: 面试整理
date: 2024-01-31 10:20:31
tags:
- js
- css
- 面试
categories:
- 前端
---


# 面试题目

## 奇点浩瀚 2024.1.31

### 项目 

#### 介绍一下零代码平台

#### 图表对接数据怎么实现的

#### 产品版本更新技术架构有哪些变化

### css

#### 实现一个垂直水平居中对齐

1. flex
2. grid: `place-items: center;`
3. table: 
    ```css
    .container {
        display: table;
        width: 100%;
        height: 100%;
    }

    .item {
        display: table-cell;
        vertical-align: middle;
        text-align: center;
    }
    ```
4. absolute/fixed + translate

#### align-item 和 align-content 的区别

`align-item`是所有项目(子元素)在交叉轴上的对齐方式

`align-content`是多根轴线的对齐方式，是多行项目的对齐方式，影响的是行与行之间的间距，如果只有一行，则不生效

#### flex中如何调整item间距

`gap: 10px 20px;`

`row-gap` 和 `column-gap`，行间距和列间距，只写一个值，则两个值相同

#### 如何实现宽度0.5px的一条线

1. 阴影
    ```css
    .line {
        /* inset 向内(可选) | x 偏移量 | y 偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */
        box-shadow: 0 0 0 0.5px #000;
    }
    ```

2. 使用伪元素 + transform缩放

3. 线性渐变

    ```css
    .line {
        height: 1px;
        background: linear-gradient(to bottom, transparent 50%, #000 50%);
    }
    ```

4. border-bottom + transform缩放

#### 用过哪些动画

1. @keyframes + animation

2. transtion

#### 用animation实现绕x轴旋转

1. 2D, rotateX, 使用transform-origin定义基准

2. 3D, 
    ```css
    .parent-dom {
        perspective: 10000px; /* 调整这个值可以改变3D效果的深度 */
    }
    .child-dom {
        animation: rotate3d 2s infinite linear; /* 动画持续2秒，无限循环，线性速度 */
        transform-origin: bottom; /* 设置旋转基点为底部 */
        transform-style: preserve-3d; /* 确保子元素保持3D位置 */    
    }
        
    ```

### js

#### 补全下方代码

```js
function doPadStart(str, maxLength, fillString) {
    // 判断str长度，用fillString补齐maxLength
  
    return str
}
let str = '123'
doPadStart(str, 5, '0') === '00123' // true
```

补充 `fillString.repeat(maxLength - str.length)`

#### call/apply/bind的区别

#### Vue3和Vue2的区别

1. diff算法

    精细化对比，最小化更新

    vue2

    当组件创建或更新时，vue均会执行内部的update函数，该函数在内部调用render函数生成虚拟dom树，组件会指向新树，然后vue将新旧两树对比，找到差异点，最终更新到真实dom

    对比差异的过程叫diff，vue在内部通过一个patch的函数完成该过程

    在对比时，vue采用深度优先、逐层比较的方式进行比对

    在判断两个节点是否相同时，vue通过虚拟节点的key和tag来进行判断的

    具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom

    在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom，如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置

    这样一直递归下去，直到整棵树完成对比。

2. api

#### Vue3的虚拟dom

## 太极计算机 2024-02-20

一面

### js

#### js发起两次请求，都是更新数据的，后者的请求先返回，更新了数据，此时前者的请求结果返回了，如何避免覆盖掉后者的数据？

首先多次请求时可以使用AbortController取消前面的请求，

#### token过期后如何无痕刷新

- 方案1. 当发起请求服务器端返回401状态码时，表示token将要过期，那么就在响应器中拦截，并请求refreshToken，新的token请求回来后更新到cookie或storage中，继续完成发起的请求
    1. 登录成功后保存token和refresh_token(过期时间长)
    2. 在响应拦截器中对401状态码引入刷新token的api调用，通过refresh_token得到新的token
    3. 替换为新的token
    4. 将错误对象里的token替换
    5. 再次发送未完成的请求，axios.request(res.config);
    6. 如果refresh_token也过期了，清除所有token，跳转登录
    7. 如果在请求新token期间又有其他请求，那么设置一个flag变量，将其他请求放入到数组中等待被执行


- 方案2. 服务器返回过期时间，前端做比对后请求刷新token，缺点要多返回一个字段；如果本地时间被篡改，会计算错误
- 方案3. 前端轮询

#### CSS中隐藏页面元素的方式

1. display:重排和重绘，不占据页面空间，不支持动画，无法响应事件
2. visibility:重绘，占据页面空间，支持动画，无法响应事件
3. opacity:重绘，占据页面空间，支持动画，可响应事件
4. width:0,height:0:重排和重绘，不占据页面空间，支持动画
5. position:absolute,left:9999px:重绘，不占据页面空间，支持动画
6. scale：无重绘和重排，占据页面空间，支持动画

#### 数组转树，当列表中没有这个parentid时，放入到根节点当中，怎么做

```js
function arrayToTree(arr, idField = 'id', parentField = 'parentId') {
  const tree = [];
  const map = new Map();

  // 首先，将数组中的元素添加到Map中，以便于快速查找
  arr.forEach(item => {
    map.set(item[idField], item);
  });

  // 然后，遍历数组，构建树结构
  arr.forEach(item => {
    const parent = map.get(item[parentField]);
    if (parent) {
      // 如果当前元素有父级，将其作为父级的子节点
      (parent.children || (parent.children = [])).push(item);
    } else {
      // 如果当前元素没有父级，将其添加到树的根节点
      tree.push(item);
    }
  });

  return tree;
}

// 示例数组
const data = [
  { id: 1, parentId: 0, name: 'Node 1' },
  { id: 2, parentId: 1, name: 'Node 1-1' },
  { id: 3, parentId: 1, name: 'Node 1-2' },
  { id: 4, parentId: 5, name: 'Node 1-1-1' },
  // ...其他节点
];

// 转换为树形结构
const tree = arrayToTree(data);

console.log(tree);
```

#### 前端如何下载一个文件

1. a标签下载

    通过设置 `<a>` 标签的 href 属性为文件的URL，并设置 download 属性为希望保存的文件名，可以触发浏览器的下载行为。

    download有兼容性问题，并且在下载跨域资源时，可能出现无法下载的情况

2. window.location.href、window.open

    打开一个新的浏览器窗口或标签页，并加载指定的URL。但这种方法不能设置下载文件的名称。

    并且可能会直接打开文件，下载多文件时

#### Vue2和Vue3的区别

##### 效率提升
1. 静态提升：元素节点和没有绑定动态内容的属性会被提升到render函数之前，Vue2是都放在render函数内，会被频繁执行

    ```html
    <h1>hello world</h1>
    <div class="header">{{title}}</div>
    ``` 
    ```js
    const hoisted1 = createVNode('h1', null, "hello world")
    const hoisted2 = { class: "header"};
    function render() {
        createVNode('div', hoisted2, title)
    }
    ```
2. 预字符串化：当编译器遇到大量连续的静态内容（20个），会直接将其编译为一个普通字符串节点，Vue会将这些节点都变成虚拟节点
3. 缓存事件处理函数：
```vue
<button @click="count++">plus</button>
```
```js
// Vue2
render(ctx){
    return createVNode("button", {
        onClick: function($event) {
            ctx.count++;
        } 
    })
}
// Vue3
render(ctx, cache){
    return createVNode("button", {
        onClick: cache[0] || cache[0] = ($event) => (ctx.count++)
    })
}
```
4. Block Tree：Vue3记录一些块节点，块节点记录了哪些是静态节点，哪些动态节点，依次对比数组中的动态节点。Vue2对比新旧虚拟树时，并不知道哪些节点是静态和动态的，只能一层一层比较，就浪费了时间在比对静态节点上
5. PatchFlag：给动态属性加上flag和注释，因此无需将所有的信息都进行比对，Vue2并不知道这个节点的哪些信息会发生变化，会对比所以信息


### 项目

#### 多个图表之间数据是如何交互的
#### 产品中主要做什么


摇树是谁完成的
proxy的应用场景
1实现单例模式
如何做路由权限管理
性能优化做了哪些
ts的泛型、元祖
es6的新特性
有哪些数据类型
symbol的用途
map和weakmap的区别，set和weakset的区别

vue依赖注入
如何下载一个文件



二面

canvas做过哪些效果
如何实现拖拽