---
title: 设计模式
tags:
  - js
  - 设计模式
categories:
  - 前端
date: 2024-04-02 15:13:26
---

## 单例模式

保证我们系统中的某一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。

```javascript
let instance = null;
class SingleObject {
  constructor() {
    if (!instance) {
      instance = this
    }
    this.name = '单例模式'
    return instance
  }
  login() {
    console.log('login...')
  }
}

const obj1 = new Singleton();
const obj2 = new Singleton();

console.log(obj1 === obj2); // 输出: true
```

## 观察者模式

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
观察者依赖于主题，主题发生变化时，观察者会收到通知并执行相应的更新逻辑。

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }

  addObserver(observer) {
    this.observers.push(observer);
  }

  removeObserver(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }

  notifyObservers() {
    this.observers.forEach(observer => observer.update());
  }
}

class Observer {
  update() {
    // 更新逻辑
  }
}

const subject = new Subject();
const observer1 = new Observer();
const observer2 = new Observer();

subject.addObserver(observer1);
subject.addObserver(observer2);

subject.notifyObservers('Hello World!');

```

## 发布订阅模式

耦合度低，发布者和订阅者没有直接的订阅关系
灵活性高，可以通过事件信道，实现多对多的通信机制

```javascript
class PubSub {
  constructor() {
    this.subscribers = {};
  }
  addSubscribe(event, handler) {
    if (!this.subscribers[event]) {
      this.subscribers[event] = [];
    }
    this.subscribers[event].push(handler);
  }
  removeSubscribe(event, handler) {
    if (!this.subscribers[event]) {
      return;
    }
    this.subscribers[event] = this.subscribers[event].filter((item) => item !== handler);
  }
  publish(event, ...args) {
    if (!this.subscribers[event]) {
      return;
    }
    this.subscribers[event].forEach((handler) => handler(...args)); 
  }
}

const pubsub = new PubSub();
pubsub.addSubscribe('event1', (data) => {
  console.log(data);
})
pubsub.publish('event1', 'Hello World!'); // 输出: Hello World!
```

## 观察者和发布订阅模式的区别

自己理解：观察者模式用数组接收，发布订阅模式用对象接收，发布订阅模式可以通过事件信道，实现多对多的通信机制。

## 工厂模式

该模式用于封装和管理对象的创建，是一种创建型模式。
工厂就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，
根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式

### 简单工厂模式

即工厂直接创建产品

![简单工厂模式](简单工厂模式UML.png)

```javascript
class Creator {
  create(name) {}
}
class ConcreteCreatorA extend Creator {
  create(name) {
    // do something
    log(`创建${name}`)
  }
}
class ConcreteCreatorB extend Creator {
  create(name) {
    // do something
    log(`创建${name}`)
  }
}
```

### 工厂方法模式

即工厂创建工厂，工厂创建产品(单一产品)

![工厂方法模式](工厂方法模式UML.png)

```javascript
class Creator {
  create(name) {}
}
class CreatorA extend Creator {
  create(name) {
    return new ProductA(name)
  }
}
class CreatorB extend Creator {
  create(name) {
    return new ProductB(name)
  }
}

class Product {
  constructor(name) {
    this.name = name
  }
}
class ProductA extend Product {
  constructor(name) {
    super(name)
  }
}
class ProductB extend Product {
  constructor(name) {
    super(name)
  }
}
```

### 抽象工厂模式

工厂创建工厂，工厂创建产品，工厂创建的产品是一系列产品的集合

![抽象工厂模式](抽象工厂模式UML.png)

```javascript
class Creator {
  createProductA() {}
  createProductB() {}
}
class CreatorA extend Creator {
  createProductA() {
    return new ProductA1() // 产品A1
  }
  createProductB() {
    return new ProductB1() // 产品B1
  }
}
class CreatorB extend Creator {
  createProductA() {
    return new ProductA2() // 产品A2
  }
  createProductB() {
    return new ProductB2() // 产品B2
  }
}
class ProductA {
  constructor() {}
}
class ProductA1 extend ProductA {}
class ProductA2 extend ProductA {}

class ProductB {
  constructor() {}
}
class ProductB1 extend ProductB {}
class ProductB2 extend ProductB {}
```

## 策略模式

定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。
策略模式改写if else

```javascript
class Strategy {
    execute() {}
}

class ConcreteStrategyA extends Strategy {
    execute() {
        console.log('Executing strategy A');
    }
}

class ConcreteStrategyB extends Strategy {
    execute() {
        console.log('Executing strategy B');
    }
}

class Context {
    constructor(strategy) {
        this.strategy = strategy;
    }

    setStrategy(strategy) {
        this.strategy = strategy;
    }

    executeStrategy() {
        this.strategy.execute();
    }
}

const strategyA = new ConcreteStrategyA();
const strategyB = new ConcreteStrategyB();
const context = new Context(strategyA);

context.executeStrategy(); // Output: Executing strategy A
context.setStrategy(strategyB);
context.executeStrategy(); // Output: Executing strategy B

```

## 装饰器模式

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式比生成子类更为灵活。

```javascript
class Component {
    operation() {
        return 'Component';
    }
}

class Decorator extends Component {
    constructor(component) {
        super();
        this.component = component;
    }

    operation() {
        return `Decorator(${this.component.operation()})`;
    }
}

class ConcreteDecoratorA extends Decorator {
    operation() {
        return `ConcreteDecoratorA(${super.operation()})`;
    }
}

class ConcreteDecoratorB extends Decorator {
    operation() {
        return `ConcreteDecoratorB(${super.operation()})`;
    }
}

const simple = new Component();
console.log(simple.operation());

const decorator1 = new ConcreteDecoratorA(simple);
console.log(decorator1.operation());

const decorator2 = new ConcreteDecoratorB(decorator1);
console.log(decorator2.operation());

```

## 适配器模式

旧类不支持新类的某些功能
写一个适配器类，利用新类实现
改动旧类，加入适配器
继续使用旧类，可以调用新类中的方法了
